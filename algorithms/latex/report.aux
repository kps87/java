\relax 
\citation{economist}
\citation{bhageshpur_council_nodate}
\citation{schwab_fourth_2016}
\citation{aurora}
\citation{ibm}
\citation{tpu}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{1}}
\citation{bachmann_analytische_1894}
\citation{landau_handbuch_1909}
\citation{mannionBubbleSort}
\citation{harel_algorithmics_2004}
\citation{heineman_algorithms_2009}
\citation{stack}
\citation{wiki}
\citation{iverson_programming_1962}
\@writefile{toc}{\contentsline {section}{\numberline {2}Sorting Algorithms}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Simple comparison-based sort: BubbleSort}{4}}
\citation{mannionBubbleSort}
\citation{mannionBubbleSort}
\citation{mannionBubbleSort}
\newlabel{bubbleSortSource}{{1}{6}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {1}Implementation of a basic Bubblesort algorithm in Java \cite  {mannionBubbleSort}. Note that there is no logic to terminate the sort procedure for an array that is already sorted.}{6}}
\citation{mannionBubbleSort}
\citation{mannionBubbleSort}
\newlabel{bubbleSortSource2}{{2}{8}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {2}Modification of the iterative bubble sort algorithm \cite  {mannionBubbleSort} to account for a best case scenario where no inversions are present.}{8}}
\citation{latexTableGenerator}
\citation{latexTableGenerator}
\@writefile{lot}{\contentsline {table}{\numberline {1}{\ignorespaces Table illustrating the BubbleSort procedure for an array of 5 elements: [5, 3, 6, 4, 1]. Iterations, and values for the indices $i$ and $j$ are enumerated in the first three columns. Values for each array element at each iteration are in columns $4-8$. Cells in light grey correspond to two elements current being compared. Cells in dark grey correspond to the current index of $i$ (the last element which will be compared), unless the element at index $i$ is being compared, in which case it is highlighed in light grey. Elements which have been sorted are highlighted in green cells. Comments are outlined in the right most column. This diagram was generated by the author \emph  {via} an online \LaTeX  table generator \cite  {latexTableGenerator}.\relax }}{9}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{bubbleSortDiagram}{{1}{9}}
\citation{hoare_algorithm_1961}
\citation{quickSort1}
\citation{quickSort2}
\citation{quickSort3}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Efficient comparison-based sort: QuickSort}{10}}
\newlabel{quickSortSource}{{3}{12}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {3}QuickSort algorithm \cite  {quickSort1, quickSort2, quickSort3} implemented in the current project.}{12}}
\citation{quickSort1}
\citation{quickSort2}
\citation{quickSort3}
\citation{quickSort1}
\citation{quickSort2}
\citation{quickSort3}
\citation{latexTableGenerator}
\citation{latexTableGenerator}
\@writefile{lot}{\contentsline {table}{\numberline {2}{\ignorespaces Tabular illustration of the QuickSort partition procedure. Dark grey cells with bold text correspond to the pivot. Light grey cells track the indices $i$ and $j$. Green cells denote swapped elements. Cyan and purple cells correspond to the partioned sub-arrays with new pivots highlighted in bold. This diagram was generated by the author \emph  {via} an online \LaTeX  table generator \cite  {latexTableGenerator}.\relax }}{14}}
\newlabel{quickSortDiagram}{{2}{14}}
\citation{bentley_general_1980}
\citation{seward1954information}
\citation{counting_sort1}
\citation{counting_sort2}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Non-comparison sort: CountingSort}{16}}
\citation{counting_sort1}
\citation{counting_sort2}
\citation{counting_sort1}
\citation{counting_sort2}
\newlabel{countingSortSource}{{4}{17}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {4}CountingSort algorithm implemented in the current project \cite  {counting_sort1, counting_sort2}.}{17}}
\citation{latexTableGenerator}
\citation{latexTableGenerator}
\@writefile{lot}{\contentsline {table}{\numberline {3}{\ignorespaces Tabular illustration of the minimum and maximum key finding and key counting approaches in QuickSort. Light grey cells correspond to the total counts, or frequencies, for each key upon summation, and dark grey cells are the cumulative sum of the frequencies of all preceding keys. This diagram was generated by the author \emph  {via} an online \LaTeX  table generator \cite  {latexTableGenerator}.\relax }}{18}}
\newlabel{countingSortDiagram1}{{3}{18}}
\citation{latexTableGenerator}
\citation{latexTableGenerator}
\@writefile{lot}{\contentsline {table}{\numberline {4}{\ignorespaces Tabular illustration of the nested $for$ (over $i$) and $while$ (over $j$) loops in lines $36-40$ of the CountingSort algorithm shown in Listing 4\hbox {}, for the array shown in Figure 3\hbox {}. The order of insertion runs over $i$ then $j$ as sorted elements are inserted into the final array (represented in grey cells). This diagram was generated by the author \emph  {via} an online \LaTeX  table generator \cite  {latexTableGenerator}.\relax }}{20}}
\newlabel{countingSortDiagram2}{{4}{20}}
\citation{heineman_algorithms_2009}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Chosen sort 1: InsertionSort}{21}}
\citation{heineman_algorithms_2009}
\citation{heineman_algorithms_2009}
\newlabel{insertionSortSource}{{5}{22}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {5}InsertionSort algorithm adadapted from \cite  {heineman_algorithms_2009} and implemented in the current project.}{22}}
\citation{latexTableGenerator}
\citation{latexTableGenerator}
\citation{latexTableGenerator}
\citation{latexTableGenerator}
\@writefile{lot}{\contentsline {table}{\numberline {5}{\ignorespaces Tabular illustration of the InsertionSort algorithm shown in Listing 5\hbox {}. Grey cells indicate the current $key$ value ($arr[i]$), light cyan cells track the element with index $j$, dark cyan cells indicate the result of pushing an element to the right, and green cells indicate elements which have been sorted as part of a previous iteration over index $i$. This diagram was generated by the author \emph  {via} an online \LaTeX  table generator \cite  {latexTableGenerator}.\relax }}{23}}
\gdef \LT@i {\LT@entry 
    {4}{273.15201pt}\LT@entry 
    {4}{20.872pt}\LT@entry 
    {3}{24.45999pt}\LT@entry 
    {1}{47.608pt}\LT@entry 
    {1}{47.608pt}\LT@entry 
    {1}{47.608pt}\LT@entry 
    {1}{47.608pt}\LT@entry 
    {1}{47.608pt}\LT@entry 
    {1}{47.608pt}\LT@entry 
    {1}{47.608pt}\LT@entry 
    {1}{47.608pt}}
\newlabel{insertionSortDiagram1}{{5}{24}}
\citation{goldstine1947planning}
\citation{mergeSortEducative}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5}Chosen sort 2: MergeSort}{25}}
\newlabel{mergeSortSource}{{6}{26}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {6}MergeSort algorithm adadapted from \cite  {mergeSortEducative} and implemented in the current project.}{26}}
\citation{mergeSortEducative}
\citation{mergeSortEducative}
\citation{lucidchart}
\citation{lucidchart}
\citation{lucidchart}
\citation{lucidchart}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Schematic of the recursive sequence of calls made by the MergeSort algorithm to create sub-arrays when provided with the input array $A = [2,3,9,5,7,6,4,8]$. Each arrow denotes a recursive call with the exact sequence of calls denoted by the number in a each circle, and the elements of each recursive sub-array shown between square brackets. Red- and grey-shaded circles correspond to first and second recursive calls in the MergeSort algorithm shown in Listing 6\hbox {}. This diagram was generated by the author using Lucidchart \cite  {lucidchart}.\relax }}{28}}
\newlabel{mergeSortDiagram1}{{1}{28}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Schematic of the sequence of merge operations made by the MergeSort algorithm when provided with the input array $A = [2,3,9,5,7,6,4,8]$. The corresponding recursive creation of sub-arrays is shown in Figure 1\hbox {} along with a description of each symbol. Each arrow indicates the merging of two-subarrays into a sorted array, as shown algorithmically lines $34-58$ of Listing 6\hbox {}. This diagram was generated by the author using Lucidchart \cite  {lucidchart}.\relax }}{29}}
\newlabel{mergeSortDiagram2}{{2}{29}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Implementation and Benchmarking}{29}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Java Application Overview}{29}}
\citation{selection_sort}
\newlabel{IntegerSorter}{{7}{31}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7}An overview of the \emph  {IntegerSorter} class and its methods.}{31}}
\newlabel{runIntegerBenchmark}{{8}{33}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {8}{An overview of the \emph  {runIntegerBenchmark()} method} in the \emph  {AlgorithmBenchmarker} class.}{33}}
\newlabel{runIntegerSortBenchmarks}{{9}{34}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {9}{An overview of the \emph  {runIntegerSortBenchmarks()} method} in the \emph  {Runner} class.}{34}}
\newlabel{main}{{10}{35}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {10}{An overview of the \emph  {main()} method} in the \emph  {Runner} class.}{35}}
\newlabel{running1}{{11}{38}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {11}{Calling the default JRE to run the algorithm benchmarks}.}{38}}
\newlabel{running2}{{12}{38}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {12}{Calling a specific JRE to run the algorithm benchmarks} class.}{38}}
\newlabel{terminalOutput1}{{13}{39}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {13}Example terminal output from running the runner.Runner() method.}{39}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces An illustrative screenshot of CPU times in milliseconds (best run time, mean run time) being written to a terminal for different algorithms and array sizes. $NaN$ values correspond to algorithms which were not benchmarked for a particular array size owing to their inefficiency.\relax }}{40}}
\newlabel{terminalOutput2}{{3}{40}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Benchmarking Results}{40}}
\citation{selection_sort}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Benchmarking results obtained from the algorithms implemented in the current work where the $y$-axis is the CPU time in milliseconds, and the $x$-axis, $n$, is the number of elements in a given array. Lines and symbols represent the mean CPU time computed over 10 iterations for each algorithm and array size. The shaded regions represent the upper (worst-case) and lower (best-case) limits of the CPU times determined over 10 iterations. Both the $x$ and $y$ axes are represent on logarithmic scales.\relax }}{41}}
\newlabel{benchmark}{{4}{41}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Benchmarking results obtained from the CountingSort algorithm implemented in the current work where the $y$-axis is the CPU time in milliseconds, and the $x$-axis, $n$, is the number of elements in a given array. Lines and symbols represent the mean CPU time computed over 10 iterations for each algorithm and array size. Each series corresponds to simulation results where the range of integers in each array has been specficially set to the value indicated by $k$. Results from MergeSort and QuickSort from Figure 4\hbox {} are included for comparitive purposes. Both the $x$ and $y$ axes are represent on logarithmic scales.\relax }}{44}}
\newlabel{benchmark2}{{5}{44}}
\@writefile{lot}{\contentsline {table}{\numberline {6}{\ignorespaces Mean CPU benchmark times (milliseconds, averaged over 10 iterations) as a function of array size ($n$) for various sorting algorithms benchmarked in the current work. $NaN$ results indicate that no sorting benchmarks were performed for a particular algorithm/array size as a result of their poor sorting efficiency.\relax }}{46}}
\gdef \LT@ii {\LT@entry 
    {3}{70.28pt}\LT@entry 
    {3}{75.5405pt}\LT@entry 
    {3}{75.5405pt}\LT@entry 
    {3}{75.5405pt}\LT@entry 
    {3}{75.5405pt}\LT@entry 
    {3}{75.5405pt}\LT@entry 
    {3}{75.5405pt}}
\newlabel{benchmarkTable}{{3.2}{47}}
\bibstyle{ieeetr}
\bibdata{report}
\bibcite{economist}{1}
\bibcite{bhageshpur_council_nodate}{2}
\bibcite{schwab_fourth_2016}{3}
\bibcite{aurora}{4}
\bibcite{ibm}{5}
\bibcite{tpu}{6}
\bibcite{bachmann_analytische_1894}{7}
\bibcite{landau_handbuch_1909}{8}
\bibcite{mannionBubbleSort}{9}
\bibcite{harel_algorithmics_2004}{10}
\bibcite{heineman_algorithms_2009}{11}
\bibcite{stack}{12}
\bibcite{wiki}{13}
\bibcite{iverson_programming_1962}{14}
\bibcite{latexTableGenerator}{15}
\bibcite{hoare_algorithm_1961}{16}
\bibcite{quickSort1}{17}
\bibcite{quickSort2}{18}
\bibcite{quickSort3}{19}
\bibcite{bentley_general_1980}{20}
\bibcite{seward1954information}{21}
\bibcite{counting_sort1}{22}
\bibcite{counting_sort2}{23}
\bibcite{goldstine1947planning}{24}
\bibcite{mergeSortEducative}{25}
\bibcite{lucidchart}{26}
\bibcite{selection_sort}{27}
